apply plugin: 'eclipse'
ext {
	aptDir='.apt_generated'
	javaVersion = "org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"
}

eclipse {
    // ネイチャーの追加
    project {
    	natures "org.springframework.ide.eclipse.core.springnature"
    }

    classpath {
        // 依存している jar の source と javadoc をダウンロードする
        downloadSources = true    // デフォルトは false
        downloadJavadoc = true    // javadoc のパスは絶対パスになる

        file {
            beforeMerged { classpath ->
                // classpath.entries.clear()
                classpath.entries.removeAll { it.kind == "src" }
                classpath.entries.removeAll { it.kind == "con" }
            }

            whenMerged { classpath ->
                // 出力をeclipse準拠に変更
                classpath.entries.findAll { it instanceof org.gradle.plugins.ide.eclipse.model.SourceFolder }*.output = ""
                classpath.entries.findAll { it.kind == "con" && it.path.startsWith("org.eclipse.jdt.launching.JRE_CONTAINER")}*.path = "${javaVersion}"

                // 重複エントリの削除
                Map entryByPath = classpath.entries.groupBy { entry -> entry.path }
                entryByPath.each { key, values ->
                    if (values.size() > 1) {
                        def entry = values.first()
                        if (entry.kind == 'src') {
                            entry.includes = []
                            entry.excludes = []
                        }
                        int index = classpath.entries.indexOf entry
                        logger.lifecycle "Removing ${values.collect { it.path }}"
                        classpath.entries.removeAll values
                        logger.lifecycle "Adding ${entry.path}"
                        classpath.entries.add index, entry
                    }
                }
            }
            withXml { provider ->
                def node = provider.asNode()
                node.appendNode( 'classpathentry', [ kind: 'src', path: '.apt_generated'])
            }
        }
        // １ディレクトリに出力する
        classpath.defaultOutputDir = file("bin")

    }
    jdt {
        file {
            withProperties {properties ->
                properties.setProperty('org.eclipse.jdt.core.compiler.processAnnotations', 'enabled')
            }
        }
    }
}


// annotation
eclipseJdt {
	doLast {
		file('.settings/org.eclipse.jdt.apt.core.prefs')
		.withWriter { writer ->
			def contents = """\
				|eclipse.preferences.version=1
				|org.eclipse.jdt.apt.aptEnabled=true
				|org.eclipse.jdt.apt.genSrcDir=.apt_generated
				|org.eclipse.jdt.apt.reconcileEnabled=true
				|"""
			writer << contents.stripMargin()
		}
        file('.factorypath').withWriter { writer ->
            def domaJar = configurations.annotationProcessor.find {
                it.name.startsWith('doma-2')
            }
            new groovy.xml.MarkupBuilder(writer).factorypath() {
                factorypathentry(kind:'EXTJAR', id:domaJar, enabled:true, runInBatchMode:false)
                factorypathentry(kind:'PLUGIN', id:"org.eclipse.jst.ws.annotations.core", enabled:true, runInBatchMode:false)
            }
        }
    }
}
